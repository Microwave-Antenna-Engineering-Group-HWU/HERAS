classdef (Abstract) POFeedSingle < POFeed
% POFeedSingle describes a general feed. It defines the interfaces to 
% be implemented by any feed to integrate seemlessly with the other 
% parts of the PO tool, and provide basic methods common to all feeds.
% It inherits from the abstract class POFeed
% Author : Louis Dufour
% Revisions : 0.1 - 25/10/2018
%
% POFeed methods (Abstract)
%    illuminate : given a set of points, give the H fields obtained by
%          illumination from the feed. All points and vectors in feed
%          CS
%
% POFeedSingle methods
%   displayFeed : display the feed either in the figure given in
%   parameters, or by creating a new figure, with the CS. The CS scale
%   is given by POobject.CSscale
%
% See POobject

    
    properties

    end
    
    methods (Abstract)

    end
    
    methods

        function farfield = FeedFarfield(obj,coverage,rho_s)
            % This method computes the farfield pattern generated by the
            % feed radiating in free space.
            
            % Transform from cartesian to polar coordinates
            [X,Y,Z]=sph2cartEM(rho_s,coverage.Theta,coverage.Phi);

            % Convert from coverage CS to feed CS
            [X_s,Y_s,Z_s] = obj.pos2CS(X,Y,Z,coverage);
            clear X Y Z;

            % Compute feed farfield (feed CS)
            [E_x_s,E_y_s,E_z_s] = obj.illuminate(X_s,Y_s,Z_s);
            clear X_s Y_s Z_s;

            % Transform feed farfield to coverage CS
            [E_x_i,E_y_i,E_z_i] = coverage.vec2CS(E_x_s,E_y_s,E_z_s, obj);
            clear E_x_s E_y_s E_z_s;

            % Express FF in polar coordinates
            [~,E_Theta,E_Phi]=cart2sphEMvec(E_x_i,E_y_i,E_z_i,coverage.Theta,coverage.Phi); 
            clear E_x_i E_y_i E_z_i;

            % Normalize FF
            spherical_wave_factor=exp(-1j*obj.k_0*rho_s)./rho_s;
            E_Theta = E_Theta   ./spherical_wave_factor;
            E_Phi   = E_Phi     ./spherical_wave_factor;
            clear spherical_wave_factor;

            % Compute vertical, horizontal, RHCP and LHCP components
            E_V = E_Theta.*coverage.cosPhi - E_Phi.*coverage.sinPhi;
            E_H = E_Theta.*coverage.sinPhi + E_Phi.*coverage.cosPhi;
            E_RHCP=1/sqrt(2)*(E_V+1i*E_H);
            E_LHCP=1/sqrt(2)*(E_V-1i*E_H);

            % Compute Gain
            D_V_dB      = 10*log10( abs(E_V)     .^2  *4*pi/(2*obj.eta_0*obj.Prad)  );
            D_H_dB      = 10*log10( abs(E_H)     .^2  *4*pi/(2*obj.eta_0*obj.Prad)  );
            D_RHCP_dB   = 10*log10( abs(E_RHCP)  .^2  *4*pi/(2*obj.eta_0*obj.Prad)  );
            D_LHCP_dB   = 10*log10( abs(E_LHCP)  .^2  *4*pi/(2*obj.eta_0*obj.Prad)  );

            % Create farfield object
            farfield = Currents2Farfield_v2();
            farfield.coverage   =coverage;
            farfield.D_RHCP_dB  =D_RHCP_dB;
            farfield.D_LHCP_dB  =D_LHCP_dB;
            farfield.D_V_dB     =D_V_dB;
            farfield.D_H_dB     =D_H_dB;
            farfield.E_Theta    =E_Theta;
            farfield.E_Phi      =E_Phi;
            farfield.E_H        =E_H;
            farfield.E_V        =E_V;
            farfield.E_RHCP     =E_RHCP;
            farfield.E_LHCP     =E_LHCP;

        end

        function disp2fig(obj,ax, CSref)
            % This method plots the feed

            if nargin == 1
                ax = [];
            elseif nargin == 2
                CSref = CSlocal(0,0,0,[1,0,0],[0,1,0],[0,0,1]);
            end

            if isempty(ax)
                ax = figure;
            else
                if isa(ax,'matlab.graphics.axis.Axes')
                    axes(ax);  hold on;
                elseif isa(ax,'matlab.ui.control.UIAxes')
                    hold(ax,'on');
                else
                    figure(ax); hold on;
                end
            end

            % Feed center of phase
            [x,y,z] = CSref.pos2CS(0,0,0,obj);
            if isa(ax,'matlab.ui.control.UIAxes')
                plot3(ax,x,y,z,'ok');
            else
                plot3(x,y,z,'ok');
            end

            % Feed as a cone
            r = linspace(0,1,5) ;
            th = linspace(0,2*pi,20) ;
            [R,T] = meshgrid(r,th) ;
            X = R.*cos(T)*obj.CSscale/2*0.1 ;
            Y = R.*sin(T)*obj.CSscale/2*0.1 ; % 0.1 creates a cone 10 times longer than wide
            Z = R*obj.CSscale/2- obj.CSscale/2;
            [X,Y,Z] = CSref.pos2CS(X,Y,Z,obj);
            if isa(ax,'matlab.ui.control.UIAxes')
                surf(ax,X,Y,Z,Z*0+1);
            else
                surf(X,Y,Z,Z*0+1);
            end
            
            % Triade
            obj.plotTriade(ax, CSref);
            if isfield(obj.plotOptions, 'FF') && obj.plotOptions.FF
                Theta = obj.theta; Phi = obj.phi;
                u = sin(Theta).*cos(Phi);
                v = sin(Theta).*sin(Phi);
                w = cos(Theta);
                CS = CSlocal(0,0,0,[1,0,0],[0,1,0],[0,0,1]);
                U=(abs(obj.E_Theta).^2+abs(obj.E_Phi).^2)/(2*obj.eta_0);
                U = 10*log10(U*4*pi/obj.Prad);
                [u,v,w] = CS.vec2CS(u,v,w,obj);
                U2 = U+abs(min(min(U)));
                if isfield(obj.plotOptions, 'FFscale') 
                    scale = obj.plotOptions.FFscale;
                else
                    scale = 0.004;
                end
                p1 = surf(u.*U2*scale+obj.position(1),...
                    v.*U2*scale+obj.position(2),...
                    w.*U2*scale+obj.position(3), U);
                p1.LineStyle = 'none';
            end
        end
    end
    
end